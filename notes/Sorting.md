# Sorting

## Insertion Sort 插入排序
给定数组a，当插入第i(i>=1)个元素时插入排序的过程中保证从位置a[0], a[1], ..., a[i-1]都是排好序的。当a[i] < a[i-1],（i >= 1）时，将a[i]插入到0至i-1中合适的位置，并将其后的元素向后顺移。

* 最差情况，初始数组逆序排列，时间复杂度O(N^2)
* 最好情况，初始数组已经顺序排列，时间复杂度O(N)
* 平均复杂度O(N^2)
* 插入排序是稳定的

![Insertion sort][1]

## Selection Sort 选择排序
每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

* 比较次数与初始情况无关，总是O(N^2
* 交换次数，最好情况初始数组已经顺序排列，交换次数为0；最差情况为n-1，逆序时为n/2
* 最好情况，初始数组已经顺序排列，
* 选择排序是不稳定的

![Selection sort][2]

## Heapsort 堆排序
堆排序相对而言比较简单，直接利用了堆的特性，这里可以使用最大堆，第i次调用最大堆的deleteMax方法获取当前最大值，并将其存入倒数第i位，将堆大小减一，这样就可以避免多余的存储空间，节省了空间成本。

* 根据输入数组进行最大堆的初始化，时间复杂度为O(N)
* 执行N次最大堆的deleteMin()方法花费O(logN)时间，执行N次，所以总共是O(NlogN)

## Shellsort 希尔排序
通过比较相距一定间隔h的元素，每趟比较所用的间隔h随算法的进行而减小，直到h=1，即比较相邻元素为止，因此又称为减小增量排序。
在使用增量h的一趟排序之后，对于每个i我们都有a[i] <= a[i+h]。

1. 在每趟比较时，各个被h间隔划分的子数组内采用插入排序。考虑到两种情况：

* 开始时，间隔h很大，每个子数组都很小
* 接近结束时，间隔h很小时，每个子数组基本上已经排好序了，此时插入排序效率很高

2. 关于间隔h的选择：

* Shell建议的增量（Shell增量）：2的幂次：1, 2, 4, ..., 2^n, 并不很好
* Hibbard增量序列：1, 3, 7, ..., 2^k-1
* 其他如 h = 3x + 1，更复杂的h = 4^x - 3 * 2^x + 1等等，效率都会比Shell增量好


3. 时间复杂度与增量的选择相关（分析很过程很复杂了，延伸阅读参见[维基百科][3]）
* 使用Shell增量的最坏情况，时间复杂度O(N^2)
* 使用Hibbard增量的最坏情况是O(N^1.5)

![Shell sort][4]

## Mergesort 归并排序
合并两个已经排序的表。由于两个表是已排序的，所以如果将输出放入第三个表中，则可以通过一趟排序完成。

* 平均运行时间是O(NlogN)
* 占用额外的O(N)的内存空间
* 拷贝数组元素的开销减慢了整体速度（可以通过在递归中交替使用原始数组和附加数组来避免）
* 相对于其他O(NlogN)的排序算法，归并排序的运行时间严重依赖于元素比较和在数组中移动元素的相对开销，这通常与语言相关
    * 例如在Java中，执行一次泛型（Comparator）排序时，由于比较操作不容易被内嵌，从而动态调度的开销可能会减缓执行速度，但是移动元素由于是引用的复制而不是对象的拷贝而是省时的。因此在Java库中泛型对象的排序采用的是归并排序，而基本数据类型的排序采用的快速排序。
* 归并排序是所有主流排序算法中比较次数最少的。
![mergesort][5]

## Quicksort 快速排序
任取待排序数组中的某个元素作为枢纽元v，将整个数组分为左右两个子数组，左边的都比v小，右边的都比v大，v处于中间。然后分别对左右子数组重复进行以上操作，直到排序完成。
```
Quicksort(array) {
    if (array 的长度大于1） {
        选取枢纽元v;
        将array分为两个子数组leftArray和rightArray;
        Quicksort(leftArray);
        Quicksort(rightArray);
        将leftArray, v, rightArray合成完整数组;
    }
}

```

快速排序与归并排序一样都是采用分治法并通过递归实现的排序，但效率却比归并快。其优势就在快排在分割子数组时是在更恰当的位置进行并且非常有效，它的高效不仅可以弥补大小不等的递归调用的不足而且还能有所超出。

* 枢纽元的选取
虽然任意一种选择方式都可以完成排序工作，但总是有优劣之分的。以下为常见的做法：
    *  总是选取第一个元素：如果输入是随机的，没问题；但是当输入是预排序或是反排序的，就很糟糕了。非常不推荐这样做哦！
    * 随机选取：一种安全的做法，但是随机数的生成开销一般比较大
    * 三数中值分割法：选取数组元素的中位数作为枢纽元，但实际应用起来很难算并且会明显降低效率。若打算采取随机选择估算的方式，然而随机性并没有多少用。因此，一般采用选取左端、右端和中心位置上的三个元素的中值作为枢纽元。

* 分割策略
一种选择是将枢纽元与最后一个元素交换位置，使得枢纽元与要被分割的数据段分离开来。

* 小数组的处理
对于很小的数组，快速排序不如插入排序，通常的做法是到给定的截止范围（如N=10，一般5-20之间都可能有不错的效果）后更小的数组不再采用快排，而是使用效率更高的插入排序（或其他）。

![quicksort][6]

* 平均运行时间O(NlogN)
* 最坏情形为O(N^2)：预排序情况
* 不稳定


  [1]: images/insertion-sort.jpg
  [2]: images/selection-sort.jpg
  [3]: https://en.wikipedia.org/wiki/Shellsort
  [4]: images/shellsort.jpg
  [5]: images/mergesort.jpg
  [6]: images/quicksort.jpg